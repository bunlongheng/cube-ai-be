import { v4 as uuidv4 } from 'uuid';
import ResultSet from './ResultSet';
import SqlQuery from './SqlQuery';
import Meta from './Meta';
import ProgressResult from './ProgressResult';
import HttpTransport from './HttpTransport';
import RequestError from './RequestError';
let mutexCounter = 0;
const MUTEX_ERROR = 'Mutex has been changed';
function mutexPromise(promise) {
    return promise
        .then((result) => result)
        .catch((error) => {
        if (error !== MUTEX_ERROR) {
            throw error;
        }
    });
}
/**
 * Main class for accessing Cube API
 */
class CubeApi {
    /**
     * Creates an instance of the `CubeApi`. The API entry point.
     *
     * ```js
     * import cube from '@cubejs-client/core';
     * const cubeApi = cube(
     *   'CUBE-API-TOKEN',
     *   { apiUrl: 'http://localhost:4000/cubejs-api/v1' }
     * );
     * ```
     *
     * You can also pass an async function or a promise that will resolve to the API token
     *
     * ```js
     * import cube from '@cubejs-client/core';
     * const cubeApi = cube(
     *   async () => await Auth.getJwtToken(),
     *   { apiUrl: 'http://localhost:4000/cubejs-api/v1' }
     * );
     * ```
     */
    constructor(apiToken, options) {
        if (apiToken && !Array.isArray(apiToken) && typeof apiToken === 'object') {
            options = apiToken;
            apiToken = undefined;
        }
        if (!options || (!options.transport && !options.apiUrl)) {
            throw new Error('The `apiUrl` option is required');
        }
        this.apiToken = apiToken;
        this.apiUrl = options.apiUrl;
        this.method = options.method;
        this.headers = options.headers || {};
        this.credentials = options.credentials;
        this.transport = options.transport || new HttpTransport({
            authorization: typeof apiToken === 'string' ? apiToken : undefined,
            apiUrl: this.apiUrl,
            method: this.method,
            headers: this.headers,
            credentials: this.credentials,
            fetchTimeout: options.fetchTimeout,
            signal: options.signal
        });
        this.pollInterval = options.pollInterval || 5;
        this.parseDateMeasures = options.parseDateMeasures;
        this.castNumerics = typeof options.castNumerics === 'boolean' ? options.castNumerics : false;
        this.networkErrorRetries = options.networkErrorRetries || 0;
        this.updateAuthorizationPromise = null;
    }
    request(method, params) {
        return this.transport.request(method, {
            baseRequestId: uuidv4(),
            ...params
        });
    }
    loadMethod(request, toResult, options, callback) {
        const mutexValue = ++mutexCounter;
        if (typeof options === 'function' && !callback) {
            callback = options;
            options = undefined;
        }
        options = options || {};
        const mutexKey = options.mutexKey || 'default';
        if (options.mutexObj) {
            options.mutexObj[mutexKey] = mutexValue;
        }
        const requestPromise = this
            .updateTransportAuthorization()
            .then(() => request());
        let skipAuthorizationUpdate = true;
        let unsubscribed = false;
        const checkMutex = async () => {
            const requestInstance = await requestPromise;
            if (options &&
                options.mutexObj &&
                options.mutexObj[mutexKey] !== mutexValue) {
                unsubscribed = true;
                if (requestInstance.unsubscribe) {
                    await requestInstance.unsubscribe();
                }
                throw MUTEX_ERROR;
            }
        };
        let networkRetries = this.networkErrorRetries;
        const loadImpl = async (response, next) => {
            const requestInstance = await requestPromise;
            const subscribeNext = async () => {
                if (options?.subscribe && !unsubscribed) {
                    if (requestInstance.unsubscribe) {
                        return next();
                    }
                    else {
                        await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));
                        return next();
                    }
                }
                return null;
            };
            const continueWait = async (wait = false) => {
                if (!unsubscribed) {
                    if (wait) {
                        await new Promise(resolve => setTimeout(() => resolve(), this.pollInterval * 1000));
                    }
                    return next();
                }
                return null;
            };
            if (options?.subscribe && !skipAuthorizationUpdate) {
                await this.updateTransportAuthorization();
            }
            skipAuthorizationUpdate = false;
            if (('status' in response && response.status === 502) ||
                ('error' in response && response.error?.toLowerCase() === 'network error') &&
                    --networkRetries >= 0) {
                await checkMutex();
                return continueWait(true);
            }
            // From here we're sure that response is only fetch Response
            response = response;
            let body = {};
            let text = '';
            try {
                text = await response.text();
                body = JSON.parse(text);
            }
            catch (_) {
                body.error = text;
            }
            if (body.error === 'Continue wait') {
                await checkMutex();
                if (options?.progressCallback) {
                    options.progressCallback(new ProgressResult(body));
                }
                return continueWait();
            }
            if (response.status !== 200) {
                await checkMutex();
                if (!options?.subscribe && requestInstance.unsubscribe) {
                    await requestInstance.unsubscribe();
                }
                const error = new RequestError(body.error || '', body, response.status);
                if (callback) {
                    callback(error);
                }
                else {
                    throw error;
                }
                return subscribeNext();
            }
            await checkMutex();
            if (!options?.subscribe && requestInstance.unsubscribe) {
                await requestInstance.unsubscribe();
            }
            const result = toResult(body);
            if (callback) {
                callback(null, result);
            }
            else {
                return result;
            }
            return subscribeNext();
        };
        const promise = requestPromise.then(requestInstance => mutexPromise(requestInstance.subscribe(loadImpl)));
        if (callback) {
            return {
                unsubscribe: async () => {
                    const requestInstance = await requestPromise;
                    unsubscribed = true;
                    if (requestInstance.unsubscribe) {
                        return requestInstance.unsubscribe();
                    }
                    return null;
                }
            };
        }
        else {
            return promise;
        }
    }
    async updateTransportAuthorization() {
        if (this.updateAuthorizationPromise) {
            await this.updateAuthorizationPromise;
            return;
        }
        const tokenFetcher = this.apiToken;
        if (typeof tokenFetcher === 'function') {
            const promise = (async () => {
                try {
                    const token = await tokenFetcher();
                    if (this.transport.authorization !== token) {
                        this.transport.authorization = token;
                    }
                }
                finally {
                    this.updateAuthorizationPromise = null;
                }
            })();
            this.updateAuthorizationPromise = promise;
            await promise;
        }
    }
    /**
     * Add system properties to a query object.
     */
    patchQueryInternal(query, responseFormat) {
        if (responseFormat === 'compact' &&
            query.responseFormat !== 'compact') {
            return {
                ...query,
                responseFormat: 'compact',
            };
        }
        else {
            return query;
        }
    }
    /**
     * Process result fetched from the gateway#load method according
     * to the network protocol.
     */
    loadResponseInternal(response, options = {}) {
        if (response.results.length) {
            if (options?.castNumerics) {
                response.results.forEach((result) => {
                    const numericMembers = Object.entries({
                        ...result.annotation.measures,
                        ...result.annotation.dimensions,
                    }).reduce((acc, [k, v]) => {
                        if (v.type === 'number') {
                            acc.push(k);
                        }
                        return acc;
                    }, []);
                    result.data = result.data.map((row) => {
                        numericMembers.forEach((key) => {
                            if (row[key] != null) {
                                row[key] = Number(row[key]);
                            }
                        });
                        return row;
                    });
                });
            }
            if (response.results[0].query.responseFormat &&
                response.results[0].query.responseFormat === 'compact') {
                response.results.forEach((result, j) => {
                    const data = [];
                    const { dataset, members } = result.data;
                    dataset.forEach((r) => {
                        const row = {};
                        members.forEach((m, i) => {
                            row[m] = r[i];
                        });
                        data.push(row);
                    });
                    response.results[j].data = data;
                });
            }
        }
        return new ResultSet(response, {
            parseDateMeasures: this.parseDateMeasures
        });
    }
    /**
     * Fetch data for the passed `query`.
     *
     * ```js
     * import cube from '@cubejs-client/core';
     * import Chart from 'chart.js';
     * import chartjsConfig from './toChartjsData';
     *
     * const cubeApi = cube('CUBEJS_TOKEN');
     *
     * const resultSet = await cubeApi.load({
     *  measures: ['Stories.count'],
     *  timeDimensions: [{
     *    dimension: 'Stories.time',
     *    dateRange: ['2015-01-01', '2015-12-31'],
     *    granularity: 'month'
     *   }]
     * });
     *
     * const context = document.getElementById('myChart');
     * new Chart(context, chartjsConfig(resultSet));
     * ```
     * @param query - [Query object](/product/apis-integrations/rest-api/query-format)
     * @param options
     * @param callback
     * @param responseFormat
     */
    load(query, options, callback, responseFormat = 'default') {
        [query, options] = this.prepareQueryOptions(query, options, responseFormat);
        return this.loadMethod(() => this.request('load', {
            query,
            queryType: 'multi',
            signal: options?.signal
        }), (response) => this.loadResponseInternal(response, options), options, callback);
    }
    prepareQueryOptions(query, options, responseFormat = 'default') {
        options = {
            castNumerics: this.castNumerics,
            ...options
        };
        if (responseFormat === 'compact') {
            if (Array.isArray(query)) {
                const patched = query.map((q) => this.patchQueryInternal(q, 'compact'));
                return [patched, options];
            }
            else {
                const patched = this.patchQueryInternal(query, 'compact');
                return [patched, options];
            }
        }
        return [query, options];
    }
    /**
     * Allows you to fetch data and receive updates over time. See [Real-Time Data Fetch](/product/apis-integrations/rest-api/real-time-data-fetch)
     *
     * ```js
     * // Subscribe to a query's updates
     * const subscription = await cubeApi.subscribe(
     *   {
     *     measures: ['Logs.count'],
     *     timeDimensions: [
     *       {
     *         dimension: 'Logs.time',
     *         granularity: 'hour',
     *         dateRange: 'last 1440 minutes',
     *       },
     *     ],
     *   },
     *   options,
     *   (error, resultSet) => {
     *     if (!error) {
     *       // handle the update
     *     }
     *   }
     * );
     *
     * // Unsubscribe from a query's updates
     * subscription.unsubscribe();
     * ```
     */
    subscribe(query, options, callback, responseFormat = 'default') {
        [query, options] = this.prepareQueryOptions(query, options, responseFormat);
        return this.loadMethod(() => this.request('subscribe', {
            query,
            queryType: 'multi',
            signal: options?.signal
        }), (response) => this.loadResponseInternal(response, options), { ...options, subscribe: true }, callback);
    }
    /**
     * Get generated SQL string for the given `query`.
     */
    sql(query, options, callback) {
        return this.loadMethod(() => this.request('sql', {
            query,
            signal: options?.signal
        }), (response) => (Array.isArray(response) ? response.map((body) => new SqlQuery(body)) : new SqlQuery(response)), options, callback);
    }
    /**
     * Get meta description of cubes available for querying.
     */
    meta(options, callback) {
        return this.loadMethod(() => this.request('meta', {
            signal: options?.signal
        }), (body) => new Meta(body), options, callback);
    }
    /**
     * Get query related meta without query execution
     */
    dryRun(query, options, callback) {
        return this.loadMethod(() => this.request('dry-run', {
            query,
            signal: options?.signal
        }), (response) => response, options, callback);
    }
}
export default (apiToken, options) => new CubeApi(apiToken, options);
export { CubeApi };
export { default as Meta } from './Meta';
export { default as SqlQuery } from './SqlQuery';
export { default as RequestError } from './RequestError';
export { default as ProgressResult } from './ProgressResult';
export { default as ResultSet } from './ResultSet';
export * from './HttpTransport';
export * from './utils';
export * from './time';
export * from './types';
