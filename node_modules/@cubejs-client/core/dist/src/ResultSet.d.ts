import { Annotation, ChartPivotRow, DrillDownLocator, LoadResponse, LoadResponseResult, PivotConfig, PivotConfigFull, PivotQuery, PivotRow, Query, QueryAnnotations, QueryType, SerializedResult, Series, SeriesNamesColumn, TableColumn, TimeDimension } from './types';
export declare const QUERY_TYPE: Record<string, QueryType>;
export type ResultSetOptions = {
    parseDateMeasures?: boolean;
};
/**
 * Provides a convenient interface for data manipulation.
 */
export default class ResultSet<T extends Record<string, any> = any> {
    private readonly loadResponse;
    private readonly loadResponses;
    private readonly queryType;
    private readonly parseDateMeasures;
    private readonly options;
    private readonly backwardCompatibleData;
    static measureFromAxis(axisValues: string[]): string;
    static timeDimensionMember(td: TimeDimension): string;
    /**
     * ```js
     * import { ResultSet } from '@cubejs-client/core';
     *
     * const resultSet = await cubeApi.load(query);
     * // You can store the result somewhere
     * const tmp = resultSet.serialize();
     *
     * // and restore it later
     * const resultSet = ResultSet.deserialize(tmp);
     * ```
     * @param data the result of [serialize](#result-set-serialize)
     * @param options
     */
    static deserialize<TData extends Record<string, any> = any>(data: SerializedResult, options?: Object): ResultSet<TData>;
    constructor(loadResponse: LoadResponse<T> | LoadResponseResult<T>, options?: ResultSetOptions);
    /**
     * Returns a measure drill down query.
     *
     * Provided you have a measure with the defined `drillMembers` on the `Orders` cube
     * ```js
     * measures: {
     *   count: {
     *     type: `count`,
     *     drillMembers: [Orders.status, Users.city, count],
     *   },
     *   // ...
     * }
     * ```
     *
     * Then you can use the `drillDown` method to see the rows that contribute to that metric
     * ```js
     * resultSet.drillDown(
     *   {
     *     xValues,
     *     yValues,
     *   },
     *   // you should pass the `pivotConfig` if you have used it for axes manipulation
     *   pivotConfig
     * )
     * ```
     *
     * the result will be a query with the required filters applied and the dimensions/measures filled out
     * ```js
     * {
     *   measures: ['Orders.count'],
     *   dimensions: ['Orders.status', 'Users.city'],
     *   filters: [
     *     // dimension and measure filters
     *   ],
     *   timeDimensions: [
     *     //...
     *   ]
     * }
     * ```
     *
     * In case when you want to add `order` or `limit` to the query, you can simply spread it
     *
     * ```js
     * // An example for React
     * const drillDownResponse = useCubeQuery(
     *    {
     *      ...drillDownQuery,
     *      limit: 30,
     *      order: {
     *        'Orders.ts': 'desc'
     *      }
     *    },
     *    {
     *      skip: !drillDownQuery
     *    }
     *  );
     * ```
     * @returns Drill down query
     */
    drillDown(drillDownLocator: DrillDownLocator, pivotConfig?: PivotConfig): Query | null;
    /**
     * Returns an array of series with key, title and series data.
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.series() will return
     * [
     *   {
     *     key: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     series: [
     *       { x: '2015-01-01T00:00:00', value: 27120 },
     *       { x: '2015-02-01T00:00:00', value: 25861 },
     *       { x: '2015-03-01T00:00:00', value: 29661 },
     *       //...
     *     ],
     *   },
     * ]
     * ```
     */
    series<SeriesItem = any>(pivotConfig?: PivotConfig): Series<SeriesItem>[];
    private axisValues;
    private axisValuesString;
    static getNormalizedPivotConfig(query?: PivotQuery, pivotConfig?: PivotConfig): PivotConfigFull;
    normalizePivotConfig(pivotConfig?: PivotConfig): PivotConfigFull;
    timeSeries(timeDimension: TimeDimension, resultIndex?: number, annotations?: Record<string, Annotation>): string[] | null;
    /**
     * Base method for pivoting [ResultSet](#result-set) data.
     * Most of the time shouldn't be used directly and [chartPivot](#result-set-chart-pivot)
     * or [tablePivot](#table-pivot) should be used instead.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     * ```js
     * // For query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-03-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.pivot({ x: ['Stories.time'], y: ['measures'] }) will return
     * [
     *   {
     *     xValues: ["2015-01-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 27120]
     *     ]
     *   },
     *   {
     *     xValues: ["2015-02-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 25861]
     *     ]
     *   },
     *   {
     *     xValues: ["2015-03-01T00:00:00"],
     *     yValuesArray: [
     *       [['Stories.count'], 29661]
     *     ]
     *   }
     * ]
     * ```
     * @returns An array of pivoted rows.
     */
    pivot(pivotConfig?: PivotConfig): PivotRow[];
    private mergePivots;
    /**
     * Returns normalized query result data in the following format.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.chartPivot() will return
     * [
     *   { "x":"2015-01-01T00:00:00", "Stories.count": 27120, "xValues": ["2015-01-01T00:00:00"] },
     *   { "x":"2015-02-01T00:00:00", "Stories.count": 25861, "xValues": ["2015-02-01T00:00:00"]  },
     *   { "x":"2015-03-01T00:00:00", "Stories.count": 29661, "xValues": ["2015-03-01T00:00:00"]  },
     *   //...
     * ]
     *
     * ```
     * When using `chartPivot()` or `seriesNames()`, you can pass `aliasSeries` in the [pivotConfig](#types-pivot-config)
     * to give each series a unique prefix. This is useful for `blending queries` which use the same measure multiple times.
     *
     * ```js
     * // For the queries
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [
     *     {
     *       dimension: 'Stories.time',
     *       dateRange: ['2015-01-01', '2015-12-31'],
     *       granularity: 'month',
     *     },
     *   ],
     * },
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [
     *     {
     *       dimension: 'Stories.time',
     *       dateRange: ['2015-01-01', '2015-12-31'],
     *       granularity: 'month',
     *     },
     *   ],
     *   filters: [
     *     {
     *       member: 'Stores.read',
     *       operator: 'equals',
     *       value: ['true'],
     *     },
     *   ],
     * },
     *
     * // ResultSet.chartPivot({ aliasSeries: ['one', 'two'] }) will return
     * [
     *   {
     *     x: '2015-01-01T00:00:00',
     *     'one,Stories.count': 27120,
     *     'two,Stories.count': 8933,
     *     xValues: ['2015-01-01T00:00:00'],
     *   },
     *   {
     *     x: '2015-02-01T00:00:00',
     *     'one,Stories.count': 25861,
     *     'two,Stories.count': 8344,
     *     xValues: ['2015-02-01T00:00:00'],
     *   },
     *   {
     *     x: '2015-03-01T00:00:00',
     *     'one,Stories.count': 29661,
     *     'two,Stories.count': 9023,
     *     xValues: ['2015-03-01T00:00:00'],
     *   },
     *   //...
     * ]
     * ```
     */
    chartPivot(pivotConfig?: PivotConfig): ChartPivotRow[];
    /**
     * Returns normalized query result data prepared for visualization in the table format.
     *
     * You can find the examples of using the `pivotConfig` [here](#types-pivot-config)
     *
     * For example:
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.tablePivot() will return
     * [
     *   { "Stories.time": "2015-01-01T00:00:00", "Stories.count": 27120 },
     *   { "Stories.time": "2015-02-01T00:00:00", "Stories.count": 25861 },
     *   { "Stories.time": "2015-03-01T00:00:00", "Stories.count": 29661 },
     *   //...
     * ]
     * ```
     * @returns An array of pivoted rows
     */
    tablePivot(pivotConfig?: PivotConfig): Array<{
        [key: string]: string | number | boolean;
    }>;
    /**
     * Returns an array of column definitions for `tablePivot`.
     *
     * For example:
     * ```js
     * // For the query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.tableColumns() will return
     * [
     *   {
     *     key: 'Stories.time',
     *     dataIndex: 'Stories.time',
     *     title: 'Stories Time',
     *     shortTitle: 'Time',
     *     type: 'time',
     *     format: undefined,
     *   },
     *   {
     *     key: 'Stories.count',
     *     dataIndex: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     type: 'count',
     *     format: undefined,
     *   },
     *   //...
     * ]
     * ```
     *
     * In case we want to pivot the table axes
     * ```js
     * // Let's take this query as an example
     * {
     *   measures: ['Orders.count'],
     *   dimensions: ['Users.country', 'Users.gender']
     * }
     *
     * // and put the dimensions on `y` axis
     * resultSet.tableColumns({
     *   x: [],
     *   y: ['Users.country', 'Users.gender', 'measures']
     * })
     * ```
     *
     * then `tableColumns` will group the table head and return
     * ```js
     * {
     *   key: 'Germany',
     *   type: 'string',
     *   title: 'Users Country Germany',
     *   shortTitle: 'Germany',
     *   meta: undefined,
     *   format: undefined,
     *   children: [
     *     {
     *       key: 'male',
     *       type: 'string',
     *       title: 'Users Gender male',
     *       shortTitle: 'male',
     *       meta: undefined,
     *       format: undefined,
     *       children: [
     *         {
     *           // ...
     *           dataIndex: 'Germany.male.Orders.count',
     *           shortTitle: 'Count',
     *         },
     *       ],
     *     },
     *     {
     *       // ...
     *       shortTitle: 'female',
     *       children: [
     *         {
     *           // ...
     *           dataIndex: 'Germany.female.Orders.count',
     *           shortTitle: 'Count',
     *         },
     *       ],
     *     },
     *   ],
     * },
     * // ...
     * ```
     * @returns An array of columns
     */
    tableColumns(pivotConfig?: PivotConfig): TableColumn[];
    totalRow(pivotConfig?: PivotConfig): ChartPivotRow;
    categories(pivotConfig?: PivotConfig): ChartPivotRow[];
    /**
     * Returns an array of series objects, containing `key` and `title` parameters.
     * ```js
     * // For query
     * {
     *   measures: ['Stories.count'],
     *   timeDimensions: [{
     *     dimension: 'Stories.time',
     *     dateRange: ['2015-01-01', '2015-12-31'],
     *     granularity: 'month'
     *   }]
     * }
     *
     * // ResultSet.seriesNames() will return
     * [
     *   {
     *     key: 'Stories.count',
     *     title: 'Stories Count',
     *     shortTitle: 'Count',
     *     yValues: ['Stories.count'],
     *   },
     * ]
     * ```
     * @returns An array of series names
     */
    seriesNames(pivotConfig?: PivotConfig): SeriesNamesColumn[];
    query(): Query;
    pivotQuery(): PivotQuery;
    /**
     * @return the total number of rows if the `total` option was set, when sending the query
     */
    totalRows(): number | null | undefined;
    rawData(): T[];
    annotation(): QueryAnnotations;
    private timeDimensionBackwardCompatibleData;
    /**
     * Can be used when you need access to the methods that can't be used with some query types (eg `compareDateRangeQuery` or `blendingQuery`)
     * ```js
     * resultSet.decompose().forEach((currentResultSet) => {
     *   console.log(currentResultSet.rawData());
     * });
     * ```
     */
    decompose(): ResultSet<any>[];
    /**
     * Can be used to stash the `ResultSet` in a storage and restored later with [deserialize](#result-set-deserialize)
     */
    serialize(): SerializedResult;
}
//# sourceMappingURL=ResultSet.d.ts.map