import 'url-search-params-polyfill';
export interface ErrorResponse {
    error: string;
}
export type TransportOptions = {
    /**
     * [jwt auth token](security)
     */
    authorization?: string;
    /**
     * path to `/cubejs-api/v1`
     */
    apiUrl: string;
    /**
     * custom headers
     */
    headers: Record<string, string>;
    credentials?: 'omit' | 'same-origin' | 'include';
    method?: 'GET' | 'PUT' | 'POST' | 'PATCH';
    /**
     * Fetch timeout in milliseconds. Would be passed as AbortSignal.timeout()
     */
    fetchTimeout?: number;
    /**
     * AbortSignal to cancel requests
     */
    signal?: AbortSignal;
};
export interface ITransportResponse<R> {
    subscribe: <CBResult>(cb: (result: R | ErrorResponse, resubscribe: () => Promise<CBResult>) => CBResult) => Promise<CBResult>;
    unsubscribe?: () => Promise<void>;
}
export interface ITransport<R> {
    request(method: string, params: Record<string, unknown>): ITransportResponse<R>;
    authorization: TransportOptions['authorization'];
}
/**
 * Default transport implementation.
 */
export declare class HttpTransport implements ITransport<Response> {
    authorization: TransportOptions['authorization'];
    protected apiUrl: TransportOptions['apiUrl'];
    protected method: TransportOptions['method'];
    protected headers: TransportOptions['headers'];
    protected credentials: TransportOptions['credentials'];
    protected fetchTimeout: number | undefined;
    private readonly signal;
    constructor({ authorization, apiUrl, method, headers, credentials, fetchTimeout, signal }: Omit<TransportOptions, 'headers'> & {
        headers?: TransportOptions['headers'];
    });
    request(method: string, { baseRequestId, signal, ...params }: any): ITransportResponse<Response>;
}
export default HttpTransport;
//# sourceMappingURL=HttpTransport.d.ts.map