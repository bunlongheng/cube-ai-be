import ResultSet from './ResultSet';
import SqlQuery from './SqlQuery';
import Meta from './Meta';
import ProgressResult from './ProgressResult';
import { ITransport, TransportOptions } from './HttpTransport';
import { ExtractTimeMembers, LoadResponse, PivotQuery, Query, QueryOrder, QueryType, TransformedQuery } from './types';
export type LoadMethodCallback<T> = (error: Error | null, resultSet: T) => void;
export type LoadMethodOptions = {
    /**
     * Key to store the current request's MUTEX inside the `mutexObj`. MUTEX object is used to reject orphaned queries results when new queries are sent. For example: if two queries are sent with the same `mutexKey` only the last one will return results.
     */
    mutexKey?: string;
    /**
     * Object to store MUTEX
     */
    mutexObj?: {
        [key: string]: any;
    };
    /**
     * Pass `true` to use continuous fetch behavior.
     */
    subscribe?: boolean;
    /**
     * A Cube API instance. If not provided will be taken from `CubeProvider`
     */
    cubeApi?: CubeApi;
    /**
     * If enabled, all members of the 'number' type will be automatically converted to numerical values on the client side
     */
    castNumerics?: boolean;
    /**
     * Function that receives `ProgressResult` on each `Continue wait` message.
     */
    progressCallback?(result: ProgressResult): void;
    /**
     * AbortSignal to cancel requests
     */
    signal?: AbortSignal;
};
export type DeeplyReadonly<T> = {
    readonly [K in keyof T]: DeeplyReadonly<T[K]>;
};
export type ExtractMembers<T extends DeeplyReadonly<Query>> = (T extends {
    dimensions: readonly (infer Names)[];
} ? Names : never) | (T extends {
    measures: readonly (infer Names)[];
} ? Names : never) | (T extends {
    timeDimensions: (infer U);
} ? ExtractTimeMembers<U> : never);
export type SingleQueryRecordType<T extends DeeplyReadonly<Query>> = ExtractMembers<T> extends never ? any : {
    [K in string & ExtractMembers<T>]: string | number | boolean | null;
};
export type QueryArrayRecordType<T extends DeeplyReadonly<Query[]>> = T extends readonly [infer First, ...infer Rest] ? SingleQueryRecordType<DeeplyReadonly<First>> | QueryArrayRecordType<Rest & DeeplyReadonly<Query[]>> : never;
export type QueryRecordType<T extends DeeplyReadonly<Query | Query[]>> = T extends DeeplyReadonly<Query[]> ? QueryArrayRecordType<T> : T extends DeeplyReadonly<Query> ? SingleQueryRecordType<T> : never;
export interface UnsubscribeObj {
    /**
     * Allows to stop requests in-flight in long polling or web socket subscribe loops.
     * It doesn't cancel any submitted requests to the underlying databases.
     */
    unsubscribe(): Promise<void>;
}
/**
 * @deprecated use DryRunResponse
 */
export type TDryRunResponse = {
    queryType: QueryType;
    normalizedQueries: Query[];
    pivotQuery: PivotQuery;
    queryOrder: Array<{
        [k: string]: QueryOrder;
    }>;
    transformedQueries: TransformedQuery[];
};
export type DryRunResponse = {
    queryType: QueryType;
    normalizedQueries: Query[];
    pivotQuery: PivotQuery;
    queryOrder: Array<{
        [k: string]: QueryOrder;
    }>;
    transformedQueries: TransformedQuery[];
};
export type ResponseFormat = 'compact' | 'default' | undefined;
export type CubeApiOptions = {
    /**
     * URL of your Cube.js Backend. By default, in the development environment it is `http://localhost:4000/cubejs-api/v1`
     */
    apiUrl: string;
    /**
     * Transport implementation to use. [HttpTransport](#http-transport) will be used by default.
     */
    transport?: ITransport<any>;
    method?: TransportOptions['method'];
    headers?: TransportOptions['headers'];
    pollInterval?: number;
    credentials?: TransportOptions['credentials'];
    parseDateMeasures?: boolean;
    resType?: 'default' | 'compact';
    castNumerics?: boolean;
    /**
     * How many network errors would be retried before returning to users. Default to 0.
     */
    networkErrorRetries?: number;
    /**
     * AbortSignal to cancel requests
     */
    signal?: AbortSignal;
    /**
     * Fetch timeout in milliseconds. Would be passed as AbortSignal.timeout()
     */
    fetchTimeout?: number;
};
/**
 * Main class for accessing Cube API
 */
declare class CubeApi {
    private readonly apiToken;
    private readonly apiUrl;
    private readonly method;
    private readonly headers;
    private readonly credentials;
    protected readonly transport: ITransport<any>;
    private readonly pollInterval;
    private readonly parseDateMeasures;
    private readonly castNumerics;
    private readonly networkErrorRetries;
    private updateAuthorizationPromise;
    constructor(apiToken: string | (() => Promise<string>) | undefined, options: CubeApiOptions);
    constructor(options: CubeApiOptions);
    protected request(method: string, params?: any): import("./HttpTransport").ITransportResponse<any>;
    private loadMethod;
    private updateTransportAuthorization;
    /**
     * Add system properties to a query object.
     */
    private patchQueryInternal;
    /**
     * Process result fetched from the gateway#load method according
     * to the network protocol.
     */
    protected loadResponseInternal(response: LoadResponse<any>, options?: LoadMethodOptions | null): ResultSet<any>;
    load<QueryType extends DeeplyReadonly<Query | Query[]>>(query: QueryType, options?: LoadMethodOptions): Promise<ResultSet<QueryRecordType<QueryType>>>;
    load<QueryType extends DeeplyReadonly<Query | Query[]>>(query: QueryType, options?: LoadMethodOptions, callback?: LoadMethodCallback<ResultSet<QueryRecordType<QueryType>>>): UnsubscribeObj;
    load<QueryType extends DeeplyReadonly<Query | Query[]>>(query: QueryType, options?: LoadMethodOptions, callback?: LoadMethodCallback<ResultSet<any>>, responseFormat?: string): Promise<ResultSet<QueryRecordType<QueryType>>>;
    private prepareQueryOptions;
    /**
     * Allows you to fetch data and receive updates over time. See [Real-Time Data Fetch](/product/apis-integrations/rest-api/real-time-data-fetch)
     *
     * ```js
     * // Subscribe to a query's updates
     * const subscription = await cubeApi.subscribe(
     *   {
     *     measures: ['Logs.count'],
     *     timeDimensions: [
     *       {
     *         dimension: 'Logs.time',
     *         granularity: 'hour',
     *         dateRange: 'last 1440 minutes',
     *       },
     *     ],
     *   },
     *   options,
     *   (error, resultSet) => {
     *     if (!error) {
     *       // handle the update
     *     }
     *   }
     * );
     *
     * // Unsubscribe from a query's updates
     * subscription.unsubscribe();
     * ```
     */
    subscribe<QueryType extends DeeplyReadonly<Query | Query[]>>(query: QueryType, options: LoadMethodOptions | null, callback: LoadMethodCallback<ResultSet<QueryRecordType<QueryType>>>, responseFormat?: ResponseFormat): UnsubscribeObj;
    sql(query: DeeplyReadonly<Query | Query[]>, options?: LoadMethodOptions): Promise<SqlQuery>;
    sql(query: DeeplyReadonly<Query | Query[]>, options?: LoadMethodOptions, callback?: LoadMethodCallback<SqlQuery>): UnsubscribeObj;
    meta(options?: LoadMethodOptions): Promise<Meta>;
    meta(options?: LoadMethodOptions, callback?: LoadMethodCallback<Meta>): UnsubscribeObj;
    dryRun(query: DeeplyReadonly<Query | Query[]>, options?: LoadMethodOptions): Promise<DryRunResponse>;
    dryRun(query: DeeplyReadonly<Query | Query[]>, options: LoadMethodOptions, callback?: LoadMethodCallback<DryRunResponse>): UnsubscribeObj;
}
declare const _default: (apiToken: string | (() => Promise<string>), options: CubeApiOptions) => CubeApi;
export default _default;
export { CubeApi };
export { default as Meta } from './Meta';
export { default as SqlQuery } from './SqlQuery';
export { default as RequestError } from './RequestError';
export { default as ProgressResult } from './ProgressResult';
export { default as ResultSet } from './ResultSet';
export * from './HttpTransport';
export * from './utils';
export * from './time';
export * from './types';
//# sourceMappingURL=index.d.ts.map